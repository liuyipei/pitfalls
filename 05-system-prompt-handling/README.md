# 05 â€” System prompt role handling differences

This single-file React demo shows the mismatch between:

- **What your app author intended** (`system` + `user` roles), and
- **What the model runtime actually receives** after adapter transformations.

## Learning outcomes

In under 5 minutes, users should be able to:

1. See how different model families may require different role-mapping templates.
2. Understand why parsers that assume a native `system` role can silently fail.
3. Apply a policy-template routing strategy (`native-system`, `preamble`, `no-system`).

## How the demo is structured

1. **Setup panel**
   - Choose model (Gemma 3, Llama 4, Qwen3, Command-A)
   - Optionally override recommended policy template
   - Edit system instruction and user content
2. **Raw model input panel**
   - Shows the wire payload generated by the selected template
3. **Harness interpretation panel**
   - Shows what a parser extracted from transport payload
4. **Why this fails panel**
   - Explains common silent-failure mode
5. **Fix panel**
   - Recommends template-based routing strategy
6. **Takeaway checklist**
   - Production reminders to copy into real harnesses

## Notes

- This app uses fixture-style rules to keep behavior deterministic and easy to inspect.
- Real runtimes differ by provider and SDK versions; always verify via request logs.

## Quick validation

From repository root:

```bash
npm test
```

This runs deterministic checks for wire payload construction and parser behavior across template modes.
